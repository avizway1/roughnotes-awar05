SCCM : Source code control System - 1 File
RCM : Revision Control System - n files, 1 Dir
CVS : Cuncurrent Version System : x files , x dir, x1 user

SVN : SubVersion : x files, x dir, x users
2005 - Git : Global Information Tracker : Linus Tarvalds

Distributed in Nature : 

git config --global user.name "Avinash"
git config --global user.email "avizway@gmail.com"

git config --list
git config --global --edit
git config --global core.editor "vim"


echo "# awar05-git1" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/avizway1/awar05-git.git
git push -u origin main

git remote -v --> Shows connected remote URLs.

git push -u origin main
git push origin main
git push


git remote add origin <repo-url>

Working Directory : Where we run "git init".. Whatever you create/modify/delete that will be tracked by Git.
Staging Area : Like a Rough Draft space. A place where you prepare files for next commit. "git add"
Repository : Your project folder containing all files and history of the changes on files.. "git commit"

git log

---

1. Check for existi9ng SSH keys
ls -al ~/.ssh

2. generate a new SSH key
ssh-keygen -t ed25519 -C "avizway@gmail.com"

keys generate and stores under "/root/.ssh/"

3. Add SSH key to the SSH Agent

eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_ed25519

4. Copy the public Key and add it in Github

cat ~/.ssh/id_ed25519.pub

ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKBqqsd4FXbtMvGtmQWpjGs4assNUOw1n61h6JTu5ioSq3 avizway@gmail.com

5. Verify

ssh -T git@github.com


---

Pull : To get the changes from remote repository to local repo.. 

Create a new branch
git branch <branch-name>		

Switch to an existing branch
git checkout feature-x (or)
git switch feature-x

Create a branch and checkout automatically
git checkout -b <branch-name>

git branch --> List the branches

git merge <branch-name>

git branch -d <branch-name>

---

Git cannot auto resolve line-level conflicts.. but giving an option to compare and choose the valid one.

---

Create a repo and add a file..

laptop --> clone --> edit the file and push it..

ec2--> clone --> Create a branch, switch, edit --> commit (dont merge)..
--> dswitch to main and get latest --> then after try to merge existing branch..

---

stash : 

git stash			--> stash changes
git stash apply		--> Apply stashed changes
git stash list		--> list all stashes
git stash show -p 	--> shows the shashed changes
git stash pop		--> apply and remove a stash

---

Git stash
Git stash >> used to save the modified files and deleted files aside
Git stash -u >> used to save/stash the untracked file which is not created/new file
Git stash list >> will show all the list of stash along with the indices(int-type) 
To escape type>> :q
Git stash apply 0(index>> int)(stash back the working directory back to apply changes)
Git stash show 0 (index>> int)( to have a look at inside of some of the stash) 
Git stash show -p 0 >> this will show us the changes in the pool tree view)
P is patch which show us all the patched up files
Git stash push -m “imp schedules api” >> Custom stashing with our own msg
Git stash branch new-branch 0 >>Creating new branch from stash for our future purpose
Git stash pop ( to bring back latest changes from stash)
Git stash clear (to completely clear all stashes)
Git stash drop 0

---


.gitignore is designed to ignore some of the file formats/directories to send/push it to remote repositopries.

First create .gitognore, add, commit and push.. then ig will ignore the file formats mentioned in gitignore file..

---

==> https://www.youtube.com/watch?v=0chZFIZLR_0


Git merge : 

You and your friend both are writing a book chapters paralally..

You wrote 3 chapters.. 
Your friend wrote 2 chapters.. 

You 2 decided to combine.. 

--> Git create a new "merge commit".
--> History clearly shows that two seperate lines of works existed and later combined.. 
--> Everyones contribution stays visible.. Transparant and accurate to get info on project status/evaluation.

git checkout main
git merge feature-x

---

GIT REBASE:

You and your friend both are writing a book chapters paralally.. 

You wrote 3 chapters.. 
Your friend wrote 2 chapters.. 

You 2 decided to combine.. 

--> Rebase moves your commits on top of another branch.
--> It creates a linear, cleaner history as if the work done in "sequence".
--> The final book contains all 5 chapters.. History looks smoother.. 

git checkout main
git rebase feature-x

---

squash

--> you actually did 20 chages in chapter 5 and save it as draft.. You dont want all these changes to be reflected in the final book.. so, you combine all those drafts into one polished version.. 

Squash combines the multiple commits into one single commit..
End of the, code is going to be the same.. 
Helps when developer do lot of small small chages or lot of simple commit.. 

---

Merge --> keeps full history, combine all authors chapters honestly..  Collaborative work, preseving real work hostory..

Rebase --> Rewite to look like one author wrote everything in an order.. cleaner commits or history..

Squash --> combine Multiple deafts into one filnal draft.. compresses history or messy commits.. 

---


cherry pick : If we have a specific commit in a specif branch, and you want to use that commit in your branch, you can use this cherry pick option.. 

We have "merge/rebase" to combine one branch to another branch.. 


git cherry-pick <commit-hash>

git log --> to find the commit hash

---


git fork













